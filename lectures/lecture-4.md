# Лекция 4

## УсПеШнАя ВеКтОрИзАцИя

Пример:

```c++
B(2:N) => A(1:N-1)
```

- `B(i) == A(i-1)`
- `B(2) == A(1)`
- `B(3) == A(2)`
- перекрытие по памяти у `A` и `B`

УсПеШнАя ВеКтОрИзАцИя может быть осуществлена даже с перекрытием по памяти:

```c++
void foo(float *a, float *b, float *c) {
    for (int i = 0; i < n; i++) {
        a[i] = a[i] + b[i] + c[i];
    }
}
```

Данный код компилируется дважды:

1. с инструкциями AMD64 (2000 года)
2. с инструкциями AMD64 и расширенным набором инструкций (указываются пользователем)

Перед циклом порождается код **автоматической диспетчеризации**, который смотрит по адресам и размеру типа, есть ли
перекрытие по памяти. Если есть, то используется вариант только с инструкциями AMD64.

Однако в прод идет оба варианта, соответственно сам объем исполняемого кода возрастает, что также сказывается и на
быстродействии.

Чтобы более грамотно указывать на возможное перекрытие по памяти, в языках встречаются специальные конструкции
(например `target` в c++). Также в том же c++ есть возможность автоматического расположения объектов в памяти,
что гарантирует их уникальность и отсутствие перекрытий по памяти.

В C99 было ключевое слово `restrict`, с помощью которого программист мог сообщать, что для объекта нет перекрытия по
памяти. На самом деле нет никакой гарантии в этом, поэтому это не самый надежный способ предотвращения перекрытий.

Некоторые компиляторы могут выводить, что им удалось векторизовать, а что нет (и по какой причине).

### Регулярный доступ к памяти

Для успешной векторизации перебора многомерных массивов их нужно выстраивать таким образом, чтобы в качестве первого
индекса при адресации указывался наиболее часто изменяемый, а последним, соответственно, изменяемый реже всего.

```c++
for (int i = 0; i < itmax; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            for (int l = 0; l < n; l++) {
                c[l][j] = c[l][j] + a[l][k] * b[k][j];
            }
        }
    }
}
```

Это обеспечит более грамотное развертывание массива, и замаппить его в памяти:

![arra-unfolding.png](images%2Flecture-4%2Farra-unfolding.png)

### Векторизация циклов

Не любой кортеж элементов массива может быть векторизирован из-за схемотехнических ограничений, т.к. физический адрес
должен по-хорошему делиться на размер страницы памяти процессора.

В векторизации могут участвовать только элементы, выровненные по адресу (например на 16 байтов, зависит от характеристик
процессора).

![leveling.png](images%2Flecture-4%2Fleveling.png)

Таким образом цикл делится на 3 части (длины неизвестны на этапе компиляции):

1. Peel loop, prologue - обрабатывается только с использованием инструкций AMD64, нужен для выравнивания адреса 2 части;
2. Main loop, векторная часть цикла - обрабатывается с использованием векторных инструкций;
3. Remainder loop, tail loop, epilogue - обрабатывается только с использованием инструкций AMD64, является остатком
   после выравнивания.

В идеале нужно сразу выравнивать данные.

### Различия по типам данных

Все операции типа сложения измеряются в процессорных циклах.

На этом можно сыграть.

Например, есть массив из 26 `int`. Без векторизации проход по нему будет происходить за 26 циклов.

При применении векторизации можно совершить проход за время от 8 до 11 циклов (в зависимости от того, где расположить в
памяти массив, и будут ли peel loop или remainder loop для выравнивания).

Однако, если элементов массивов 28 (число кратное 4), то можно сократить это время до 7 циклов, т.к. весь массив можно
расположить в памяти так, чтобы векторизировать его полностью.

### Способы выравнивания

В c++ есть множество конструкций для конфигурирования выравнивания:

- `_mm_malloc`
- `posix_memalign`
- `__declspec`

Также есть конструкции для сообщения компилятору, что данные выравнены:

- `#pragma vector aligned`
- `__assume_aligned`

### Блочная работа с СОЗУ

```c++
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        c += a[i] * b[j];
    }
}
```

Алгоритмическая сложность данного кода равен O(n*m).

Чтобы ее уменьшить, можно поработать с блочной памятью, разбив массив на блоки:

```c++
for (int jout = 0; jout < m; jout += block) {
   for (int i = 0; i < n; i++) {
       for (int j = jout; j < jout + block; j++) {
           c += a[i] * b[j];
       }
   }
}
```

Из-за того, что чтение может осуществляться блоками, можно вычитывать не по количеству элементов, а по количеству 
блоков, объединяющих элементы в количестве, которое позволяет хранить в себе СОЗУ. Таким образом алгоритмическая 
сложность кода становится ниже:  

O(m / block * (n + block)) = O(m * n / block + m)

### Условия векторизации

- данные должны быть сплошными
- должен быть обеспечен регулярный доступ к памяти
- первый элемент вектора должен быть выровнен
- не должно быть перекрытий по памяти
- не должно быть зависимостей итераций типа чтения после записи
