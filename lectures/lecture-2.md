# Лекция 2

## Процессорные оптимизации

Можно оптимизировать программу под конкретную платформу/инструкции целевого процессора.

Чтобы использовать доступные на процессоре наборы инструкций, их можно указать явно указать при компиляции.

```shell
icl /QxE main.cpp
```

Некоторые компиляторы используют автоматическую диспетчеризацию. Автоматическая диспетчеризация позволяет получить код,
использующий преимущества наборов инструкций, доступных для текущего процессора.

```shell
icl /QaxP main.cpp
```

При этом компилируется 2 версии программы: для платформы **amd-64** и версия, использующую указанный набор инструкций.

Можно оптимизировать точность вычислений при работе с числами с плавающей запятой.

- `-Op` (`-mp` Linux) – строгие вычисления в плавающей запятой **ANSI C** и **IEEE 754** (определяют, как хранится
  вещественное число, сколько бит занимает порядок и мантисса); высокая точность, но медленная работа приложения;
- `-Za` (`-ansi` Linux) – еще более высокая точность и еще более медленная работа приложения
- `-Qlong_double` (Intel EM64T) – изменяет размер чисел типа `long double` с 64 до 80;
- `-Qprec_div` (`-prec_div` Linux) – преобразовывает операцию деления в обратный оператор умножения; снижает точность,
  но увеличивает быстродействие
- `Qpc[32|64|80]` (`-pc[32|64|80]` Linux) – указывает размер для всех типов переменных.

Встроенные методы оптимизации в каждой IDE может отличаться.

Можно заменить стандартные математические библиотеки на сторонние, позволяют увеличить быстродействие за счет, например,
векторизации.

### Высокоуровневые оптимизации

Пример - loop unrolling

```c++
for (int i = 1; i < 1000; i++) {
    y[i] = y[i] + a * x[i];
}
```

Если процессор поддерживает **ldfp** (load floating-point pair), можно оптимизировать код следующим образом:

```c++
for (int i = 1; i < 1000; i+=2) {
    y[i] = y[i] + a * x[i];
    y[i+1] = y[i+1] + a * x[i+1];
}
```

Подобные оптимизации применяются при использовании 3 уровня оптимизации компилятором.

### Межпроцедурная оптимизация

В рамках одного файла может быть несколько функций, вызывающих друг друга,

```c++
void main() {
    for (int i = 1; i < 1000; i+=2) {
        x(i);
    }
}

void x(int i) {
    cout << i;
}
```

Можно применить оптимизацию sub-expression elimination (подробнее об inline-функциях
см. в [лекции 1](lecture-1.md)):

```c++
void main() {
    for (int i = 1; i < 1000; i+=2) {
        x(i);
    }
}

__attribute__((const)) void x(int i) {
    cout << i;
}
```

Аттрибуты могут быть:

- `pure` – функция не изменяет глобальные переменные кроме возврата значений; возвращаемое значение
  зависит от значений аргументов функции;
- `const` – функция не имеет доступа к глобальным переменным, может работать только с аргументами; в основном
  используется для оптимизаций **sub-expression elimination** и **loop optimization**.

Также можно применять оптимизации по отношению к функциям, расположенным в разных файлах.

Процесс компиляции при межпроцедурной оптимизации нескольких файлов

1. первичная компиляция с генерацией o-файлов с информацией об использовании функций друг другом
2. компоновка с межпроцедурной оптимизацией

Стоит указывать больше мета-информации компилятору, чтобы избежать излишней агрессивной оптимизации.

### Profile-guided оптимизация

Использует профилирование для сбора более подробной информации, используемой для дальнейшей оптимизации.

Для профилирования используется инструментальная компиляция приложения для взаимодействия с профайлером.

При помощи профайлера можно собрать профиль приложения с информацией о хотспотах, диапазонах значений переменных и т.д.

На основе данного профиля компилятор сможет более корректно выбрать оптимизации, способствующие увеличению качеств
приложения, и скомпилировать приложение, оптимально работающие в тех же условиях, что было запущено профилируемое
приложение.

Если при профилировании запустить приложение на нерелевантных данных, соответственно могут быть применены оптимизации,
ухудшающие качества приложения на рабочих данных.

Основной issue, который может произойти, это утечка памяти.
