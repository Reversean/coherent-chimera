# Лекция 1

## Системные методы оптимизации

Основная тема – работа над оптимизацией машинного кода.

Одна из главных проблем оптимизации – разделение памяти по разным устройствам:

- СОЗУ – кэш-память процессора, обращаться быстрее всего, но небольшой объем памяти;
- ОЗУ – обращение идет дольше, но объем памяти больше.

Архитектуры современных процессоров соответствуют архитектуре Фон-Неймана (процессор берет данные и команды
непосредственно из его кэша, но большая часть данных для работы процессора получается из ОЗУ по шине данных).

Оперативная память хоть и является довольно быстрой (быстрее, чем получение данных с внешних интерфейсов), т.к. работает
на частоте шины данных процессора, однако обращение по этой шине данных занимает значительное время (большее, чем
непосредственный доступ к данным кэша процессора). При этом ОЗУ может быть довольно большой по объему (максимум 2^34GB
на 64-битных системах).

Доступ к кэшу процессора занимает меньше времени, т.к. он находится на одном кристалле с процессором и не требует
обращения по шине данных. Однако память кэша сильно ограничена (1 уровень – $\leq$ 128 KB, 2 уровень – 1-2 МB, 3 уровень
– $\leq$ 24 MB).

Соответственно одним из способов оптимизации программы – уменьшение объема ее машинного кода с целью попытаться
полностью разместить все ее символы в памяти процессора и свести на нет обращение к шине данных.

**Символ** – функция/подпрограмма/переменная/ресурс, доступный в памяти процессора.

Компиляторы могут включать в себя оптимизации разных типов:

- оптимизации под типы приложений (оптимизация размера кода и его времени выполнения, как с ущербом для его размера, так
  и без него);
- процессорные оптимизации (оптимизация под конкретный процессор, диспетчеризация процессов);
- дополнительные оптимизации (оптимизация математических функций, управление точностью float-данных).

**Стандартные уровни оптимизации** – стандарт компиляторов системных оптимизаций. Т.к. реализация оптимизаций у каждого
компилятора может быть захардкожена, выделяют несколько уровней, различных по степени влияния на компилируемый код:

- `Od` (`O0`) – отключение оптимизации, нужно при дебаге приложения, дает доступ к символьной информации (связь
  машинного кода с исходным);
- `Os` – оптимизации для уменьшения объема кода;
- `O1` – допускаются оптимизации, не приводящие к увеличению объема кода (кроме введения inline-функций);
- `O2` – допускаются оптимизации, ускоряющие код и допускающие небольшой (насколько???) прирост объема кода;
- `O3` – high-level optimization, агрессивные методы оптимизации, могут замедлить время компиляции, рекомендуются при
  интенсивном использовании float-вычисления или больших массивов данных;
- `fast` – ~~что-то там про псевдонимы~~, у каждого компилятора оптимизация может включать солянку из вообще чего
  угодно, видимо поэтому этот уровень классифицировать довольно-таки проблемно.

С увеличением уровня оптимизации конечный код будет сильнее отличаться от исходного кода.

В зависимости от типа приложения логично применять определенные уровни оптимизации.

**Inline-функция** – встраиваемые функции/фрагменты кода в точки вызова вместо вынесения ее как отдельный ресурс.
Позволяет увеличить производительность в случаях, где мы можем выйграть за счет встраивания в контекст (не требуется
сохранять стэк вызовов, очищать его, не нужно передавать параметры функции). Например, если функция вызывается в одной и
той же точке множество раз (цикл), то разумно заинлайнить эту функцию. 
